
from typing import List
import binascii
from pathlib import Path
import re
import subprocess
import argparse

# sh4 : On M1 with homebrew, this is invoked with...

# python3 tools/gen_sdk_symbols_cpp.py \
#   -sdk r9 -sdk-folder ~/sdk-collection/r9/Libraries/Gnu/ \
#   -sdk r10 -sdk-folder ~/sdk-collection/r10/Libraries/Gnu \
#   -sdk r11b -sdk-folder ~/sdk-collection/r11b/Libraries/Gnu/ \
#   -objdump /opt/homebrew/Cellar/binutils/2.38_1/bin/gobjdump \
#   -o new.cpp 

# .. or, with the KOS toolchains ...

# python3 ./tools/gen_sdk_symbols_cpp.py \
#   -sdk r9 -sdk-folder ~/.wine/drive_c/KATANA/R9/Lib/Gnu/ \
#   -sdk r10 -sdk-folder ~/.wine/drive_c/KATANA/R10.1/Lib/Gnu/ \
#   -sdk r11 -sdk-folder ~/.wine/drive_c/KATANA/R11/Lib/Gnu/ \
#   -objdump /opt/toolchains/dc/sh-elf/bin/sh-elf-objdump \
#   -o test.txt


TEMPLATE_START = """

// WARNING : This file is generated by gen_sdk_symbols_cpp.py

#include "frontend/sdk_symbols.h"
#include "shared/types.h"

static const std::vector<SDKSymbol> g_sdk_symbols {
"""

TEMPLATE_END = """
};

const std::vector<SDKSymbol>& get_sdk_symbols() {
  return g_sdk_symbols;
}

"""

class SDKSymbol:
  def __init__(self, sdk, archive_name, symbol_name, first_return_hash, total_length, total_hash):
    self.sdk = sdk
    self.archive_name = archive_name
    self.symbol_name = symbol_name
    self.first_return_hash = first_return_hash
    self.total_length = total_length
    self.total_hash = total_hash
    self.is_ambiguous = False
    self.flag_for_removal = False

def is_return(low, high):
  RETURN_OPCODES = [
    0b0000000000001011, # RET
    0b0000000000101011, # RTE
  ]

  opcode = high << 8 | low
  return opcode in RETURN_OPCODES

def get_first_return_len(input_bytes):
  assert len(input_bytes) % 2 == 0, "Functions must be 16bit multiple"
  for i in range(0, len(input_bytes), 2):
    if is_return(input_bytes[i], input_bytes[i+1]):
      return i
  # assert False, "Couldn't find return from function"
  return -1 

def hash(input_bytes):
  return binascii.crc32(bytes(input_bytes))

def process_archive_lines(lines):
  symbol = ""
  symbol_bytes = []

  for i in range(len(lines)):

    if '.obj.elf' in lines[i]:
      print(f"New OBJ:", lines[i])

    # New symbol?
    m = re.match(r".*<([_a-zA-Z0-9]+)>:", lines[i])
    if m:
      if len(symbol) > 0:
        yield symbol, symbol_bytes
        symbol, symbol_bytes = "", []

      symbol = m.group(1)

    # print(lines[i])
    m = re.match(r"\s*([a-fA-F0-9]+):\s*([a-fA-F0-9]+)\s+([a-fA-F0-9]+).*", lines[i])
    if m:
      offset, byte1, byte2 = m.group(1), m.group(2), m.group(3)
      symbol_bytes.append(int(byte1, 16))
      symbol_bytes.append(int(byte2, 16))

  if len(symbol) > 0:
        yield symbol, symbol_bytes
        symbol, symbol_bytes = "", []

if __name__ == "__main__":
  parser = argparse.ArgumentParser()
  parser.add_argument("-objdump", default="objdump", help="Path to objdump executable")
  parser.add_argument("-sdk", help="SDK identifier for source generation", action="append")
  parser.add_argument("-sdk-folder", help="folder containing archives from the SDK", action="append")
  parser.add_argument("-o", help="output file path")
  args = parser.parse_args()

  sdk_names = args.sdk
  sdk_paths = args.sdk_folder

  assert len(sdk_names) > 0
  assert len(sdk_names) == len(sdk_paths)

  generated_symbol_data: List[SDKSymbol] = []

  for sdk_i in range(len(sdk_names)):
    # SDK Name
    sdk_name = args.sdk[sdk_i]
    assert sdk_name

    # SDK Archives path
    sdk_folder = Path(args.sdk_folder[sdk_i])
    assert sdk_folder.is_dir()

    archive_file_paths = [str(archive.absolute()) for archive in sdk_folder.glob("*.a")]
    archive_file_paths = list(filter(lambda x: '_d.a' not in x, archive_file_paths))

    assert len(archive_file_paths) > 0

    for archive in archive_file_paths:
      m = re.match(r".*/([_a-zA-Z0-9]+\.a)", archive)
      if m:
        archive_name = m.group(1)
      else:
        assert False, ""

      # Some libraries seem to be ~duplicates of others
      block_list = [
        'libsh4nlfzz.a',
        'libsofdecfx.a',
        'libsg_mw.a',
        'libsg_mwk2a.a',
        'libpwnetd.a',
        'libcri_adxs.a',
        ]
      if archive_name in block_list:
        continue

      print(f"Processing '{sdk_name}'.'{archive}'...")

      try:
        output = subprocess.check_output(f"\"{args.objdump}\" -d \"{archive}\"", shell=True)
      except:
        print("!! Failed to process", archive)

      lines = [line.strip() for line in output.decode("utf-8").split('\n')]
      for (symbol_name, symbol_bytes) in process_archive_lines(lines):
        print(f' - Processing {archive_name} {symbol_name}')
        first_return = get_first_return_len(symbol_bytes)
        if first_return < 0:
          # Has no return/exit
          print("   - HAS NO RETURN !!!!")
          continue
        if first_return == 0:
          first_return_hash = 0
        else:
          first_return_hash = hash(symbol_bytes[:first_return])
        total_hash = hash(symbol_bytes)

        sdk_symbol = SDKSymbol(
          sdk=sdk_name, 
          archive_name=archive_name, 
          symbol_name=symbol_name,
          first_return_hash=first_return_hash,
          total_length=len(symbol_bytes),
          total_hash=total_hash
        )

        if len(symbol_bytes) < 10:
          print("Filtering out", symbol_name)
          continue
        generated_symbol_data.append(sdk_symbol)

  # Check for ambiguity
  for i in range(len(generated_symbol_data)):
    for j in range(i+1, len(generated_symbol_data)):
      sym_i, sym_j = generated_symbol_data[i], generated_symbol_data[j]
      if sym_i.total_hash == sym_j.total_hash:
        # print(f"Entry '{sym_i.symbol_name}' is ambiguous with '{sym_j.symbol_name}")
        sym_i.is_ambiguous = True

  assert args.o
  output_file = open(args.o, 'w')
  output_file.write(TEMPLATE_START)
  for sym in generated_symbol_data:
    output_file.write(f'  SDKSymbol {{ "{sym.sdk}", "{sym.archive_name}", "{sym.symbol_name}", {hex(sym.first_return_hash)}, {sym.total_length}, {hex(sym.total_hash)}, {1 if sym.is_ambiguous else 0} }},\n')
    # Use the below instead for ghidra-format symbols
    # output_file.write(f'0x{sym.total_hash:x}@{sym.total_length}@{sym.sdk}@{sym.archive_name}@{sym.symbol_name}\n')
  output_file.write(TEMPLATE_END)

