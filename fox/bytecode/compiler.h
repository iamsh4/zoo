// vim: expandtab:ts=2:sw=2

#pragma once

#include "fox/jit/register_allocator.h"
#include "fox/bytecode/bytecode.h"

namespace fox {
namespace bytecode {

/*!
 * @class bytecode::Compiler
 * @brief Implementation of a IR-based bytecode compiler.
 */
class Compiler {
public:
  /*!
   * @brief Create an executable bytecode routine from an IR translation. The
   *        incoming source will be modified by the optimization pass, so
   *        must be given entirely to the compiler.
   */
  std::unique_ptr<jit::Routine> compile(ir::ExecutionUnit &&source);

private:
  /*!
   * @brief The input IR source currently being compiled.
   */
  ir::ExecutionUnit m_source;

  /*!
   * @brief Temporary buffer to store the generated bytecode program before
   *        place it into a Routine.
   */
  u8 m_result[32768];

  /*!
   * @brief The number of bytes used from the m_result buffer. Incremented as
   *        compilation continues.
   */
  size_t m_result_size = 0lu;

  /*!
   * @brief The RTL opcodes synthesized by the initial IR scan, used for
   *        register assignments.
   */
  jit::RtlProgram m_rtl;

  /*!
   * @brief Mapping from IR SSA registers to RTL registers.
   */
  std::vector<jit::RtlRegister> m_ir_to_rtl;

  /*!
   * @brief First stage of compilation that converts the incoming IR
   *        instruction sequence into an RTL bytecode instruction sequence.
   */
  void generate_rtl();

  /*!
   * @brief Second stage of compilation that assigns actual registers to
   *        each RTL instruction.
   */
  void assign_registers();

  /*!
   * @brief Final stage of compilation that encodes an RTL program as a sequence
   *        of bytecode instructions.
   */
  void assemble();

  /*!
   * @brief Either return the existing RTL SSA assignment for the operand or
   *        generate RTL instructions to load a constant and return its RTL
   *        SSA assignment.
   *
   * If operand is not a constant, it must already be in the IR->RTL mapping.
   */
  jit::RtlRegister get_rtl_ssa(ir::Operand operand);

  /*!
   * @brief Allocate a new RTL register to represent an IR operand. The operand
   *        must be a register (not a constant) and the mapping will be stored
   *        so it can be returned later by calls to get_rtl_ssa.
   */
  jit::RtlRegister make_rtl_ssa(ir::Operand operand);

  /*!
   * @brief Helper method to return human-readable names for RTL opcode IDs.
   */
  static const char *rtl_opcode_names(u16 opcode);
};

}
}
