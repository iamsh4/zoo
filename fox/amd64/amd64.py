#!/usr/bin/env python3


import os
import string
import sys


REGISTERS = {
# 8 bit
    'al':   { 'size': 8, 'encoding': 0,  'base': 'RAX' },
    'bl':   { 'size': 8, 'encoding': 3,  'base': 'RBX' },
    'cl':   { 'size': 8, 'encoding': 1,  'base': 'RCX' },
    'dl':   { 'size': 8, 'encoding': 2,  'base': 'RDX' },
    'sil':  { 'size': 8, 'encoding': 6,  'base': 'RSI' },
    'dil':  { 'size': 8, 'encoding': 7,  'base': 'RDI' },
    'bpl':  { 'size': 8, 'encoding': 5,  'base': 'RBP' },
    'spl':  { 'size': 8, 'encoding': 4,  'base': 'RSP' },
    'r8b':  { 'size': 8, 'encoding': 8,  'base': 'R8'  },
    'r9b':  { 'size': 8, 'encoding': 9,  'base': 'R9'  },
    'r10b': { 'size': 8, 'encoding': 10, 'base': 'R10' },
    'r11b': { 'size': 8, 'encoding': 11, 'base': 'R11' },
    'r12b': { 'size': 8, 'encoding': 12, 'base': 'R12' },
    'r13b': { 'size': 8, 'encoding': 13, 'base': 'R13' },
    'r14b': { 'size': 8, 'encoding': 14, 'base': 'R14' },
    'r15b': { 'size': 8, 'encoding': 15, 'base': 'R15' },

# 16 bit
    'ax':   { 'size': 16, 'encoding': 0,  'base': 'RAX' },
    'bx':   { 'size': 16, 'encoding': 3,  'base': 'RBX' },
    'cx':   { 'size': 16, 'encoding': 1,  'base': 'RCX' },
    'dx':   { 'size': 16, 'encoding': 2,  'base': 'RDX' },
    'si':   { 'size': 16, 'encoding': 6,  'base': 'RSI' },
    'di':   { 'size': 16, 'encoding': 7,  'base': 'RDI' },
    'bp':   { 'size': 16, 'encoding': 5,  'base': 'RBP' },
    'sp':   { 'size': 16, 'encoding': 4,  'base': 'RSP' },
    'r8w':  { 'size': 16, 'encoding': 8,  'base': 'R8'  },
    'r9w':  { 'size': 16, 'encoding': 9,  'base': 'R9'  },
    'r10w': { 'size': 16, 'encoding': 10, 'base': 'R10' },
    'r11w': { 'size': 16, 'encoding': 11, 'base': 'R11' },
    'r12w': { 'size': 16, 'encoding': 12, 'base': 'R12' },
    'r13w': { 'size': 16, 'encoding': 13, 'base': 'R13' },
    'r14w': { 'size': 16, 'encoding': 14, 'base': 'R14' },
    'r15w': { 'size': 16, 'encoding': 15, 'base': 'R15' },

# 32 bit
    'eax':  { 'size': 32, 'encoding': 0,  'base': 'RAX' },
    'ebx':  { 'size': 32, 'encoding': 3,  'base': 'RBX' },
    'ecx':  { 'size': 32, 'encoding': 1,  'base': 'RCX' },
    'edx':  { 'size': 32, 'encoding': 2,  'base': 'RDX' },
    'esi':  { 'size': 32, 'encoding': 6,  'base': 'RSI' },
    'edi':  { 'size': 32, 'encoding': 7,  'base': 'RDI' },
    'ebp':  { 'size': 32, 'encoding': 5,  'base': 'RBP' },
    'esp':  { 'size': 32, 'encoding': 4,  'base': 'RSP' },
    'r8d':  { 'size': 32, 'encoding': 8,  'base': 'R8'  },
    'r9d':  { 'size': 32, 'encoding': 9,  'base': 'R9'  },
    'r10d': { 'size': 32, 'encoding': 10, 'base': 'R10' },
    'r11d': { 'size': 32, 'encoding': 11, 'base': 'R11' },
    'r12d': { 'size': 32, 'encoding': 12, 'base': 'R12' },
    'r13d': { 'size': 32, 'encoding': 13, 'base': 'R13' },
    'r14d': { 'size': 32, 'encoding': 14, 'base': 'R14' },
    'r15d': { 'size': 32, 'encoding': 15, 'base': 'R15' },

# 64 bit
    'rax':  { 'size': 64, 'encoding': 0,  'base': 'RAX' },
    'rbx':  { 'size': 64, 'encoding': 3,  'base': 'RBX' },
    'rcx':  { 'size': 64, 'encoding': 1,  'base': 'RCX' },
    'rdx':  { 'size': 64, 'encoding': 2,  'base': 'RDX' },
    'rsi':  { 'size': 64, 'encoding': 6,  'base': 'RSI' },
    'rdi':  { 'size': 64, 'encoding': 7,  'base': 'RDI' },
    'rbp':  { 'size': 64, 'encoding': 5,  'base': 'RBP' },
    'rsp':  { 'size': 64, 'encoding': 4,  'base': 'RSP' },
    'r8':   { 'size': 64, 'encoding': 8,  'base': 'R8'  },
    'r9':   { 'size': 64, 'encoding': 9,  'base': 'R9'  },
    'r10':  { 'size': 64, 'encoding': 10, 'base': 'R10' },
    'r11':  { 'size': 64, 'encoding': 11, 'base': 'R11' },
    'r12':  { 'size': 64, 'encoding': 12, 'base': 'R12' },
    'r13':  { 'size': 64, 'encoding': 13, 'base': 'R13' },
    'r14':  { 'size': 64, 'encoding': 14, 'base': 'R14' },
    'r15':  { 'size': 64, 'encoding': 15, 'base': 'R15' },
}

HEADER_TOP = '''
#pragma once

/***************************************************************************
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING *
 ***************************************************************************/

/*
 * The contents of this file are automatically generated by a python script.
 * Do not modify them directly.
 */

#include <vector>
#include <cstring>

#include "fox/fox_types.h"
#include "amd64/amd64_types.h"

namespace fox {
namespace codegen {
namespace amd64 {

class Assembler {
public:
  Assembler()
  {
    m_buffer.resize(2048u, 0);
  }

  ~Assembler(){}

  u8* data()
  {
    return &m_buffer[0];
  }

  const u8* data() const
  {
    return &m_buffer[0];
  }

  size_t size() const
  {
    return m_offset;
  }

  void clear()
  {
    m_offset = 0lu;
  }
'''.lstrip('\n')

SIGNATURE = '''
  /* {mnemonic} */
  void {name}({arguments});
'''.lstrip('\n')

HEADER_BOTTOM = '''
private:
  /* TODO */
  std::vector<u8> m_buffer;
  size_t m_offset = 0lu;

  void emit8(const u8 value)
  {
    if (m_offset + sizeof(value) > m_buffer.size()) {
      m_buffer.resize(m_buffer.size() * 3 / 2, 0u);
    }
    m_buffer[m_offset++] = value;
  }

  void emit16(const u16 value)
  {
    if (m_offset + sizeof(value) > m_buffer.size()) {
      m_buffer.resize(m_buffer.size() * 3 / 2, 0u);
    }
    memcpy(&m_buffer[m_offset], &value, sizeof(value));
    m_offset += sizeof(value);
  }

  void emit32(const u32 value)
  {
    if (m_offset + sizeof(value) > m_buffer.size()) {
      m_buffer.resize(m_buffer.size() * 3 / 2, 0u);
    }
    memcpy(&m_buffer[m_offset], &value, sizeof(value));
    m_offset += sizeof(value);
  }

  void emit64(const u64 value)
  {
    if (m_offset + sizeof(value) > m_buffer.size()) {
      m_buffer.resize(m_buffer.size() * 3 / 2, 0u);
    }
    memcpy(&m_buffer[m_offset], &value, sizeof(value));
    m_offset += sizeof(value);
  }
};

}
}
}
'''.strip('\n')

SOURCE_TOP = '''
#include <cstdio>
#include <cassert>

#include "amd64/amd64_assembler.h"

/***************************************************************************
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING *
 ***************************************************************************/

/*
 * The contents of this file are automatically generated by a python script.
 * Do not modify them directly.
 */

#define REX_B = (1u << 0u)
#define REX_X = (1u << 1u)
#define REX_R = (1u << 2u)
#define REX_W = (1u << 3u)

namespace fox {
namespace codegen {
namespace amd64 {

template <typename Operand>
void
modrm_sib(unsigned &rex_b, unsigned &rex_x,
          unsigned &modrm_rm, unsigned &modrm_mod,
          unsigned &sib, int32_t &displacement,
          const Operand &operand)
{
  if (operand.is_memory()) {
    if (operand.has_scaled_index()) {
      assert(operand.has_base());
      unsigned sib_base, sib_index, sib_scale;
      if (operand.has_offset()) {
        displacement = operand.offset();
        if (displacement >= -128 && displacement <= 127) {
          modrm_mod = 1;
        } else {
          modrm_mod = 2;
        }
      } else {
        modrm_mod = 0;
      }
      sib_base = operand.base().encoding();
      sib_index = operand.index().encoding();
      switch (operand.scale()) {
        case 1: sib_scale = 0u; break;
        case 2: sib_scale = 1u; break;
        case 4: sib_scale = 2u; break;
        case 8: sib_scale = 3u; break;
        default: sib_scale = 0u; assert(false);
      }
      sib = (sib_base & 7u) | ((sib_index & 7u) << 3) | (sib_scale << 6);
      modrm_rm = 4;
      rex_b = (sib_base & 8u) >> 3;
      rex_x = (sib_index & 8u) >> 3;
    } else if (operand.has_offset()) {
      /* Fixed displacement addressing in 32-bit mode is replaced with RIP-
       * relative displacement in 64-bit mode. A base must be available. */
      assert(operand.has_base());
      assert(operand.base().encoding() != RSP);
      displacement = operand.offset();
      modrm_rm = operand.base().encoding();
      if (displacement >= -128 && displacement <= 127) {
        modrm_mod = 1;
      } else {
        modrm_mod = 2;
      }
      rex_b = (modrm_rm & 8u) >> 3u;
    } else {
      assert(operand.has_base());
      assert(operand.base().encoding() != RSP);
      assert(operand.base().encoding() != RBP);
      modrm_rm = operand.base().encoding();
      modrm_mod = 0;
      rex_b = (modrm_rm & 8u) >> 3u;
    }
  } else {
    modrm_rm = operand.direct().encoding();
    modrm_mod = 3;
    rex_b = (modrm_rm & 8u) >> 3u;
  }
}
'''.lstrip('\n')

SOURCE_BOTTOM = '''
}
}
}
'''.strip('\n')

WRAPPER_REGMEM = '''
  /* {name} [reg{size}], [reg/mem{size}] (virtual wrapper) */

  void {name}({ctype_rm} operand0, {ctype_rm} operand1)
  {{
    assert(!operand0.is_memory());
    {name}(operand0.direct(), operand1);
  }}

  void {name}({ctype_reg} operand0, {ctype_reg} operand1)
  {{
    {name}(operand0, RegMem<{size_name}>(operand1));
  }}
'''.lstrip('\n')

WRAPPER_MEMREG = '''
  /* {name} [reg/mem{size}], [reg{size}] (virtual wrapper) */
  void {name}({ctype_rm} operand0, {ctype_rm} operand1)
  {{
    assert(!operand1.is_memory());
    {name}(operand0, operand1.direct());
  }}

  void {name}({ctype_reg} operand0, {ctype_reg} operand1)
  {{
    {name}(RegMem<{size_name}>(operand0), operand1);
  }}
'''.lstrip('\n')

WRAPPER_MEMMEM = '''
  /* {name} [reg/mem{size}], [reg/mem{size}] (virtual wrapper) */
  void {name}({ctype_rm} operand0, {ctype_rm} operand1)
  {{
    if (operand0.is_memory()) {{
      assert(!operand1.is_memory());
      {name}(operand0, operand1.direct());
    }} else if (operand1.is_memory()) {{
      {name}(operand0.direct(), operand1);
    }} else {{
      {name}(operand0.direct(), operand1);
    }}
  }}

  void {name}({ctype_reg} operand0, {ctype_reg} operand1)
  {{
    {name}(RegMem<{size_name}>(operand0), operand1);
  }}
'''.lstrip('\n')

START_DEFINITION = '''
/* {mnemonic} */
void
Assembler::{name}({arguments})
{{
'''.strip('\n')

END_DEFINITION = '''
}}
'''.lstrip('\n')

LOCAL = '''
  unsigned {name} = {value};
'''.strip('\n')

EMIT_REX = '''
  if (rex_b || rex_x || rex_r || rex_w) {
    u8 rex = 0x40u;
    rex |= (rex_b << 0u);
    rex |= (rex_x << 1u);
    rex |= (rex_r << 2u);
    rex |= (rex_w << 3u);
    emit8(rex);
  }
'''.strip('\n')

EMIT_REX_REG_BYTE_CHECK = '''
  if (({name}.encoding() & 0xC) == 0x4) {{
    rex_force = 1;
  }}
'''

EMIT_REX_REGMEM_BYTE_CHECK = '''
  if (!{name}.is_memory() && ({name}.direct().encoding() & 0xC) == 0x4) {{
    rex_force = 1;
  }}
'''

EMIT_REX_BYTE = '''
  u8 rex = 0x40u;
  if (rex_b || rex_x || rex_r || rex_w || rex_force) {
    rex |= (rex_b << 0u);
    rex |= (rex_x << 1u);
    rex |= (rex_r << 2u);
    rex |= (rex_w << 3u);
    emit8(rex);
  }
'''.strip('\n')

MODRM_SIB = '''
  unsigned rex_b, rex_x = 0;
  unsigned modrm_rm, modrm_mod;
  unsigned sib = 0;
  int32_t displacement = 0;
  modrm_sib(rex_b, rex_x, modrm_rm, modrm_mod, sib, displacement, {operand});
'''.lstrip('\n')

EMIT_MODRM = '''
  const u8 modrm = (modrm_rm & 0x07u) |
                   ((modrm_reg & 0x07u) << 3) |
                   ((modrm_mod & 0x03u) << 6);
  emit8(modrm);
  if (modrm_mod != 3 && modrm_rm == 4) {{
    emit8(sib);
  }}
  if (modrm_mod == 1) {{
    emit8(static_cast<u8>(displacement));
  }} else if (modrm_mod == 2) {{
    emit32(static_cast<u32>(displacement));
  }}
'''.strip('\n')

EMIT_BYTE = '''
  emit8({:});
'''.strip('\n')

EMIT_IMM8 = '''
  emit8({:});
'''.strip('\n')

EMIT_IMM16 = '''
  emit16({:});
'''.strip('\n')

EMIT_IMM32 = '''
  emit32({:});
'''.strip('\n')

EMIT_IMM64 = '''
  emit64({:});
'''.strip('\n')


#
# Some mnemonics have base names that are also keywords in C++, like 'and'.
# For these we prefix the name with '_' to form the method name in the
# assembler.
#
def escape_name(name):
    keywords = [
        'and', 'or', 'xor', 'not'
    ]
    if name in keywords:
        return '_' + name
    return name


#
# Parse all fields in an instruction mnemonic to determine the name and
# operands of the instruction. Assumes Intel syntax (destination on the left).
#
# Example return value:
# {
#     'name':     'mov',
#     'operands':  [ 'eax', 'moffset32'],
# }
#
def parse_mnemonic(mnemonic):
    if ' ' in mnemonic:
        name, operand_string = mnemonic.split(' ', 1)
        operands = [ x.strip() for x in operand_string.split(',') ]
        return {
            'mnemonic': mnemonic,
            'name': name,
            'operands': operands,
        }
    else:
        # No operands
        assert ',' not in mnemonic
        return {
            'mnemonic': mnemonic,
            'name': mnemonic,
            'operands': [],
        }


#
# Parse the array of encoding strings into something easier to generate an
# instruction's bytes with.
#
# /digit
#     - The 'digit' present is placed into the ModRM's reg field.
# /r
#     - The ModRM field is placed here, and it specifies two arguments
# cb, cw, cd, cp
#     - 1, 2, 4, or 6 byte code-offset value
# ib, iw, id, iq
#     - Immediate value of 1, 2, 4, or 8 bytes. Little endian.
# +rb, +rw, +rd, +rq
#     - Add a register code to the byte immediately to the left to form the
#       actual opcode.
# m64
#     - Specifies a 64-bit value operand in memory
#
def parse_encoding(encoding):
    # For now, only combine the +r[bwdq] with the prior byte and drop the size,
    # to make parsing it easier in the emit code generation.
    result = []
    for b in encoding:
        if b in [ '+rb', '+rw', '+rd', '+rq' ]:
            result[-1] = result[-1] + '+r'
        else:
            result.append(b)
    return result


#
# Split an instruction encoding into prefix and postfix portions. The prefix
# consists of fixed bytes used to modify the chosen instruction that must come
# before dynamic prefixes like REX.
#
def split_encoding(encoding):
    prefix = []
    postfix = []
    end_prefix = False
    for b in encoding:
        if not b in [ '66', 'F2', 'F3' ]:
            end_prefix = True
        if end_prefix:
            postfix.append(b)
        else:
            prefix.append(b)
    return prefix, postfix


#
# Return the size in bits of an mnemonic's operand.
#
def operand_size(operand):
    size8 = [ 'reg/mem8', 'reg8', 'moffset8', 'imm8', 'imm8s', 'rel8off' ]
    size16 = [ 'reg/mem16', 'reg16', 'moffset16', 'imm16', 'imm16s', 'rel16off' ]
    size32 = [ 'reg/mem32', 'xmm/mem32', 'xmm32', 'reg32', 'moffset32', 'imm32', 'imm32s', 'rel32off' ]
    size64 = [ 'reg/mem64', 'xmm/mem64', 'xmm64', 'reg64', 'moffset64', 'imm64', 'imm64s', 'rel64off' ]
    size128 = [ 'xmm/mem128', 'xmm128' ]

    if operand in size8:
        return 8
    elif operand in size16:
        return 16
    elif operand in size32:
        return 32
    elif operand in size64:
        return 64
    elif operand in size128:
        return 128
    elif operand in REGISTERS:
        # Specific / hard-coded register
        return REGISTERS[operand]['size']

    assert False


#
# Return the type of operand (without size)
#
def operand_type(operand):
    TABLE = {
        'reg/mem8':   'reg/mem',
        'reg/mem16':  'reg/mem',
        'reg/mem32':  'reg/mem',
        'reg/mem64':  'reg/mem',
        'xmm/mem32':  'reg/mem',
        'xmm/mem64':  'reg/mem',
        'xmm/mem128': 'reg/mem',
        'mem8':       'mem',
        'mem16':      'mem',
        'mem32':      'mem',
        'mem64':      'mem',
        'mem128':     'mem',
        'reg8':       'reg',
        'reg16':      'reg',
        'reg32':      'reg',
        'reg64':      'reg',
        'xmm32':      'reg',
        'xmm64':      'reg',
        'xmm128':     'reg',
        'moffset8':   'moffset',
        'moffset16':  'moffset',
        'moffset32':  'moffset',
        'moffset64':  'moffset',
        'imm8':       'imm',
        'imm16':      'imm',
        'imm32':      'imm',
        'imm64':      'imm',
        'imm8s':      'imm',
        'imm16s':     'imm',
        'imm32s':     'imm',
        'rel8off':    'imm',
        'rel16off':   'imm',
        'rel32off':   'imm',
        'rel64off':   'imm',
    }

    if operand in TABLE:
        return TABLE[operand]
    if operand in REGISTERS:
        return 'fixedreg'

    assert False


#
# Return the C++ type that should be used for the given mnemonic's operand.
#
def operand_ctype(operand):
    TABLE = {
        'reg/mem8':   'RegMem<BYTE>',
        'reg/mem16':  'RegMem<WORD>',
        'reg/mem32':  'RegMem<DWORD>',
        'reg/mem64':  'RegMem<QWORD>',
        'xmm/mem32':  'RegMemVector<DWORD>',
        'xmm/mem64':  'RegMemVector<QWORD>',
        'xmm/mem128': 'RegMemVector<XMM>',
        'mem8':       'Address<BYTE>',
        'mem16':      'Address<WORD>',
        'mem32':      'Address<DWORD>',
        'mem64':      'Address<QWORD>',
        'reg8':       'Register<BYTE>',
        'reg16':      'Register<WORD>',
        'reg32':      'Register<DWORD>',
        'reg64':      'Register<QWORD>',
        'xmm32':      'Vector<DWORD>',
        'xmm64':      'Vector<QWORD>',
        'xmm128':     'Vector<XMM>',
        'moffset8':   'FixedAddress<BYTE>',
        'moffset16':  'FixedAddress<WORD>',
        'moffset32':  'FixedAddress<DWORD>',
        'moffset64':  'FixedAddress<QWORD>',
        'imm8':       'u8',
        'imm16':      'u16',
        'imm32':      'u32',
        'imm64':      'u64',
        'imm8s':      'i8',
        'imm16s':     'i16',
        'imm32s':     'i32',
        'imm64s':     'i64',
        'rel8off':    'i8',
        'rel16off':   'i16',
        'rel32off':   'i32',
        'rel64off':   'i64',
    }
    SIZE_TABLE = {
        8:   'BYTE',
        16:  'WORD',
        32:  'DWORD',
        64:  'QWORD',
        128: 'XMM',
    }

    if operand in TABLE:
        return TABLE[operand]
    if operand in REGISTERS:
        size = SIZE_TABLE[REGISTERS[operand]['size']]
        value = REGISTERS[operand]['base']
        return 'FixedRegister<' + size + ',' + value + '>'

    assert False


#
# ...
#
def write_signature(fp, opcode):
    details = {
        'name': escape_name(opcode['name']),
        'arguments': ', '.join([ operand_ctype(x) for x in opcode['operands'] ]),
        'mnemonic':  opcode['mnemonic']
    }
    print(SIGNATURE.format(**details), file=fp)


#
# ...
#
def write_wrapper(fp, size, opcode, first_mem, second_mem):
    details = {
        'name': escape_name(opcode['name']),
        'arguments': ', '.join([ operand_ctype(x) for x in opcode['operands'] ]),
        'mnemonic':  opcode['mnemonic'],
        'ctype_rm': operand_ctype('reg/mem' + str(size)),
        'ctype_reg': operand_ctype('reg' + str(size)),
        'size': size,
        'size_name': { 8: 'BYTE', 16: 'WORD', 32: 'DWORD', 64: 'QWORD', 128: 'XMM' }[size]
    }
    if first_mem and second_mem:
        print(WRAPPER_MEMMEM.format(**details), file=fp)
    elif first_mem:
        print(WRAPPER_MEMREG.format(**details), file=fp)
    else:
        assert second_mem
        print(WRAPPER_REGMEM.format(**details), file=fp)


#
#
#
def write_definition(fp, opcode):
    details = {
        'mnemonic': opcode['mnemonic'],
        'name': escape_name(opcode['name'])
    }

    require_mod = False

    # Generate C definitions for each instruction operand, and determine which
    # operands have special treatment (SIB / RM)
    operands = opcode['operands']
    arguments = []
    rm_operand = None  # Which argument gets the ModRM rm fields
    r_operand = None   # Which argument gets the ModRM reg fields
    dtype = None       # The operand type for the combo source+dest register
    immediate = None   # Which operand gets the immediate value
    moffset = None     # Which operand gets the moffset
    has_byte = False   # True if there's at least one 8-bit reg or reg/mem operand
    for i in range(len(operands)):
        name = 'operand' + str(i)
        ctype = operand_ctype(operands[i])
        otype = operand_type(operands[i])
        arguments.append(f'const {ctype} {name}')

        if otype == 'reg/mem':
            assert rm_operand is None
            rm_operand = i
            if operand_size(operands[i]) == 8:
                has_byte = True
        elif otype == 'reg':
            assert r_operand is None
            r_operand = i
            if operand_size(operands[i]) == 8:
                has_byte = True
        elif otype == 'imm':
            assert immediate is None
            immediate = i
        elif otype == 'moffset':
            moffset = i
        if i == 0:
            dtype = otype

    details['arguments'] = ', '.join(arguments)

    print(START_DEFINITION.format(**details), file=fp)

    # Write the fixed opcode prefix. These are used to distinguish between
    # multiple opcode maps.
    for byte in opcode['prefix']:
        assert all(c in '0123456789ABCDEF' for c in byte[0:2])
        assert len(byte) == 2
        print(EMIT_BYTE.format('0x' + byte[0:2]), file=fp)

    # Check how the instruction will, overall, end up being encoded.
    #   - Check if the ModRM byte will be emitted, and whether it specifies one
    #     or two operands.
    #   - Check if the opcode specifies a register operand with an opcode offset
    modrm = False
    modrm_digit = None
    reg_offset = False
    for byte in opcode['encoding']:
        if len(byte) > 2 and byte[2:].startswith('+r'):
            assert reg_offset == False
            reg_offset = True
            continue
        if byte == '/r':
            assert modrm == False
            modrm = True
            continue

        if len(byte) != 2:
            continue
        if byte[0] == '/' and byte[1] in '01234567':
            assert modrm == False
            modrm = True
            modrm_digit = int(byte[1])
            continue

    # reg_offset wants to use REX.b, but reg/mem fields need REX.b for some
    # SIB encodings.
    if reg_offset:
        assert modrm == False

    # Instructions that have a combo reg/mem operand are generated twice, once
    # for the register version and once for the memory version. Choose the
    # type for the reg/mem operand in this instance.
    #if rm_operand is not None:
    #    operands

    # Values for prefixes.
    rex_w = 0
    rex_r = 0
    rex_x = 0
    rex_b = 0
    modrm_reg = 0

    if modrm:
        if modrm_digit is None:
            assert r_operand is not None
            modrm_reg = f'operand{r_operand}.encoding()'
        else:
            assert r_operand is None
            modrm_reg = modrm_digit

        assert rm_operand is not None
        print(MODRM_SIB.format(operand=f'operand{rm_operand}'), file=fp)

    if reg_offset:
        assert dtype == 'reg' # Assuming operand0 is being encoded
        assert modrm == False # XXX ?
        rex_b = '(operand0.encoding() & 8u) ? 1u : 0u'
    elif modrm:
        if modrm_digit is None:
            # XXX Should assert that there's no other "normal" reg field
            rex_r = '(modrm_reg & 8u) ? 1u : 0u'
        # rex_b / rex_x are generated as part of the MODRM_SIB block
        rex_b = None
        rex_x = None

    # Values for the ModRM byte

    # Size prefixes for general purpose instructions, where default size is 32:
    #     REX.W    66h    Size
    #     0        0      32
    #     1        N/A    64
    #     0        1      32
    #
    # REX is optional for size encoding if W=0.
    need_size_prefix = False
    if opcode['default_size'] == 32:
        if opcode['effective_size'] == 16:
            need_size_prefix = True
            rex_w = 0
        elif opcode['effective_size'] == 64:
            require_rex = True
            rex_w = 1
    else:
        rex_w = 0

    # Emit size prefix for 16-bit operations
    if need_size_prefix:
        print(EMIT_BYTE.format('0x66'), file=fp)

    # Generate the ModRM field data. Generate emit code it if necessary.
    if modrm:
        print(LOCAL.format(name='modrm_reg', value=str(modrm_reg)), file=fp)

    # Generate REX field. Emit only happens when if necessary, unless there's
    # a single-byte reg or reg/mem operand in the instruction that maps to
    # SIL / DIL / BPL / SPL.
    assert rex_w is not None
    if has_byte:
        # XXX If there's a byte operand, force rex even if it has no 1s in the
        #     W X R B bits. Otherwise the encoding for SIL / DIL is wrong.
        if rex_b is not None:
            print(LOCAL.format(name='rex_b', value=str(rex_b)), file=fp)
        if rex_x is not None:
            print(LOCAL.format(name='rex_x', value=str(rex_x)), file=fp)
        print(LOCAL.format(name='rex_r', value=str(rex_r)), file=fp)
        print(LOCAL.format(name='rex_w', value=str(rex_w)), file=fp)
        print(LOCAL.format(name='rex_force', value='0'), file=fp)
        for i in range(len(operands)):
            otype = operand_type(operands[i])
            name = 'operand' + str(i)
            if otype == 'reg':
                print(EMIT_REX_REG_BYTE_CHECK.format(name=name), file=fp)
            elif otype == 'reg/mem':
                print(EMIT_REX_REGMEM_BYTE_CHECK.format(name=name), file=fp)
            name = 'operand' + str(i)
        print(EMIT_REX_BYTE, file=fp)
    elif not (rex_w == 0 and rex_r == 0 and rex_x == 0 and rex_b == 0):
        if rex_b is not None:
            print(LOCAL.format(name='rex_b', value=str(rex_b)), file=fp)
        if rex_x is not None:
            print(LOCAL.format(name='rex_x', value=str(rex_x)), file=fp)
        print(LOCAL.format(name='rex_r', value=str(rex_r)), file=fp)
        print(LOCAL.format(name='rex_w', value=str(rex_w)), file=fp)
        print(EMIT_REX, file=fp)

    for byte in opcode['postfix']:
        if all(c in '0123456789ABCDEF' for c in byte[0:2]):
            # Raw byte, but optionally modified to encode a
            # register if followed by '+r'
            assert len(byte) == 2 or len(byte) == 4
            if len(byte) == 2:
                print(EMIT_BYTE.format('0x' + byte[0:2]), file=fp)
            elif len(byte) == 4 and byte.endswith('+r'):
                assert dtype == 'reg' # XXX
                result = '0x' + byte[0:2] + ' + (operand0.encoding() & 7)'
                print(EMIT_BYTE.format(result), file=fp)
            else:
                assert False
        elif byte == '/r':
            print(EMIT_MODRM.format(**details), file=fp)
        elif len(byte) == 2 and byte.startswith('/') and byte[1] in '01234567':
            print(EMIT_MODRM.format(**details), file=fp)
        elif byte == 'ib' or byte == 'cb':
            print(EMIT_IMM8.format(f'operand{immediate}'), file=fp)
        elif byte == 'iw' or byte == 'cw':
            print(EMIT_IMM16.format(f'operand{immediate}'), file=fp)
        elif byte == 'id' or byte == 'cd':
            print(EMIT_IMM32.format(f'operand{immediate}'), file=fp)
        elif byte == 'iq':
            print(EMIT_IMM64.format(f'operand{immediate}'), file=fp)
        else:
            assert False

    # Memory offset operands aren't included in the opcode format. Emit them
    # now. They're always 64-bit immediates, the number attached is just the
    # size of the memory access.
    if moffset is not None:
        print(EMIT_IMM64.format(f'operand{moffset}.value()'), file=fp)

    print(END_DEFINITION.format(**details), file=fp)


#
# Opcode table format:
#
#     ; Comments
#     MNEMONIC | OPCODE | DEFAULT_SIZE
#
raw_opcode_table = open(sys.argv[1], 'r').readlines()
raw_opcode_table = [ x for x in raw_opcode_table if not x.strip().startswith(';') ]
raw_opcode_table = [ x for x in raw_opcode_table if not x.strip() == '' ]
opcode_table = [ [ y.strip() for y in x.split('|') ] for x in raw_opcode_table ]
opcode_table = [ x for x in opcode_table if not x[0].strip() == '' ]
instructions = []
for opcode in opcode_table:
    mnemonic = parse_mnemonic(opcode[0])
    effective_size = 0
    if len(mnemonic['operands']) > 0:
        effective_size = operand_size(mnemonic['operands'][0])
    instruction = {
        **mnemonic,
        'encoding': parse_encoding(opcode[1].strip().split(' ')),
        'default_size': int(opcode[2]),
        'effective_size': effective_size,
        'wrap': False
    }
    instruction['prefix'], instruction['postfix'] = split_encoding(instruction['encoding'])
    instructions.append(instruction)


# Search for opcodes with memory operand support. These will be wrapped to
# provide a consistent RegMem-only interface that can call the appropriate
# internal emit method. The wrapper is not used for variants with a fixed
# register argument or an immediate value.
has_regmem = { 8: set(), 16: set(), 32: set(), 64: set(), 128: set() }
has_memreg = { 8: set(), 16: set(), 32: set(), 64: set(), 128: set() }
for instruction in instructions:
    if len(instruction['operands']) != 2:
        continue
    first = instruction['operands'][0]
    second = instruction['operands'][1]
    size = operand_size(first)
    if size != operand_size(second):
        continue
    elif 'xmm' in first or 'xmm' in second:
        # TODO Add xmm support for wrappers
        continue

    if operand_type(first) == 'reg/mem' and operand_type(second) == 'reg':
        has_memreg[size].add(instruction['name'])
    elif operand_type(first) == 'reg' and operand_type(second) == 'reg/mem':
        has_regmem[size].add(instruction['name'])
    else:
        continue

    instruction['wrap'] = True

add_wrapper = {}
for size in [ 8, 16, 32, 64, 128 ]:
    add_wrapper[size] = has_regmem[size] | has_memreg[size]

# Generate the emit code.
out_ext = os.path.splitext(sys.argv[2])[1]
if out_ext == '.h':
    header_fp = open(sys.argv[2], 'w')
    print(HEADER_TOP, file=header_fp)
    for instruction in instructions:
        name = instruction['name']
        for size in [ 8, 16, 32, 64, 128 ]:
            if not name in add_wrapper[size]:
                continue
            first_mem = name in has_memreg[size]
            second_mem = name in has_regmem[size]
            write_wrapper(header_fp, size, instruction, first_mem, second_mem)

            # Only emit the wrappers once per mnemonic name
            add_wrapper[size].remove(name)

        write_signature(header_fp, instruction)
    print(HEADER_BOTTOM, file=header_fp)
elif out_ext == '.cpp':
    source_fp = open(sys.argv[2], 'w')
    print(SOURCE_TOP, file=source_fp)
    for instruction in instructions:
        write_definition(source_fp, instruction)
    print(SOURCE_BOTTOM, file=source_fp)
else:
    assert False
