#!/usr/bin/env python3


import json
import sys
from enum import Enum
from typing import List, Dict, Tuple
import re
import argparse


verbose = False


class ArgType(Enum):
  Immediate = 0
  GPR32 = 1
  GPR64 = 2
  FP32 = 3
  FP64 = 4
  FP128 = 5
  Condition = 6
  Label = 7
  ShiftMode = 8
  ExtensionMode = 9


class FunctionArgument:
  def __init__(self, name, type_):
    self.name = name
    self.type = type_

  def __repr__(self):
    return f"({self.name}, {self.type})"


header_file_template = '''
#pragma once

/***************************************************************************
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING *
 ***************************************************************************/

/*
 * The contents of this file are automatically generated by a python script.
 * Do not modify them directly.
 */

#include <map>
#include <vector>
#include <variant>

#include "fox/fox_types.h"

namespace fox {
namespace codegen {
namespace arm64 {

namespace Extension {
  enum Mode {
    UXTB = 0,
    UXTH,
    UXTW_LSL,
    UXTX,
    SXTB,
    SXTH,
    SXTW,
    SXTX
  };
}

namespace Condition {
  enum Code {
    Equal = 0,
    NotEqual,
    CarrySet,
    CarryClear,
    Negative,
    PositiveOrZero,
    Overflow,
    NoOverflow,
    UnsignedGreater,
    UnsignedLessThanOrEqual,
    SignedGreaterThanOrEqual,
    SignedLessThan,
    SignedGreaterThan,
    SignedLessThanOrEqual,
    Always,
    Always2 // Equivalent to Always
  };
}

namespace RegisterShift {
  enum Mode {
    LSL = 0b00,
    LSR = 0b01,
    ASR = 0b10
  };
}

struct Immediate { u32 value; Immediate(u32 value) : value(value) { } };

template<int bits>
struct GPR { u32 value; };

template<int bits>
struct FPR { u32 value; };

namespace Registers {
  inline GPR<32> W(u32 num) { return GPR<32>{num}; }
  inline GPR<64> X(u32 num) { return GPR<64>{num}; }
  inline FPR<32> S(u32 num) { return FPR<32>{num}; }
  inline FPR<64> D(u32 num) { return FPR<64>{num}; }
}

class Assembler {
public:
  struct Label {
    u32 index;
  };

  struct Intermediate {
    static const u32 NO_LABEL = 0xFFFFFFFF;

    u32 encoding;
    u32 index;

    u32 label_assignment;
    u32 label_lshift = 0;
    u32 label_nbits = 0;

    Intermediate(u32 encoding, u32 index) : encoding(encoding), index(index), label_assignment(NO_LABEL) { }
    void set_branch_label(const Intermediate& other) { label_assignment = other.index; }
  };

  using Constant = std::variant<u32, u64>;

private:
  std::vector<std::variant<Intermediate, Label>> buffer;
  void emit(Intermediate intermediate);

  std::map<u32, Constant> constants;
  u32 current_label_count = 0;

public:
  std::vector<u32> assemble();
  Label create_label();
  void push_label(Label);

  Label create_constant(const Constant& val);

FUNC_LIST
};

}
}
}
'''

cpp_file_template = '''
/***************************************************************************
 * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING *
 ***************************************************************************/

/*
 * The contents of this file are automatically generated by a python script.
 * Do not modify them directly.
 */

#include <unordered_map>

#include "arm64/arm64_assembler.h"
#include "arm64/arm64_logical_immediates.h"

namespace fox {
namespace codegen {
namespace arm64 {

static LogicalImmediates logical_immediates;

void Assembler::emit(Assembler::Intermediate intermediate) {
  buffer.push_back(intermediate);
}

std::vector<u32> Assembler::assemble() {

  // Compute location in the code for each label
  u32 current_code_count = 0;
  std::unordered_map<u32, u32> label_to_code_location;

  // Compute locations for branch labels
  for(u32 i=0; i<buffer.size(); ++i) {
    const auto& var = buffer[i];
    if(std::holds_alternative<Label>(var)) {
      const Label& label = std::get<Label>(var);
      label_to_code_location[label.index] = current_code_count;
      //printf("i=%u label=%u current_code_count=%u\\n", i, label.index, current_code_count);
    } else {
      current_code_count++;
      //printf("i=%u current_code_count=%u\\n", i, current_code_count);
    }
  }

  // Compute output position for Constants.
  const u32 instruction_count = current_code_count;
  u32 constant_count = 0;
  for(auto& [label_index, _] : constants)
  {
    //printf("constant_count=%u instruction_count=%u label_index=%u\\n", constant_count, instruction_count, label_index);
    label_to_code_location[label_index] = instruction_count + constant_count;
    constant_count++;
  }

  // Resolve labels and encode in dependent instructions
  u32 instructions=0;
  for(auto& var : buffer) {
    if(std::holds_alternative<Intermediate>(var)) {
      auto& intermediate = std::get<Intermediate>(var);
      if(intermediate.label_assignment != Assembler::Intermediate::NO_LABEL) {
        u32 label_location = label_to_code_location[intermediate.label_assignment];
        const i32 distance = label_location - instructions;
        //printf("Resolving i=%u label=%u label_location=%u distance=%d\\n", instructions, intermediate.label_assignment, label_location, distance);
        const u32 mask = (1 << intermediate.label_nbits) - 1;
        u32 thing = (distance << intermediate.label_lshift) & (mask << intermediate.label_lshift);
        intermediate.encoding |= thing;
      }
      instructions++;
    }
  }

  std::vector<u32> result;
  for(auto& var : buffer)
    if(std::holds_alternative<Intermediate>(var)) {
      auto& intermediate = std::get<Intermediate>(var);
      result.push_back( intermediate.encoding );
    }

  // Add constant data to the end of the routine storage
  for(auto& [label_index, constant] : constants)
    if(std::holds_alternative<u32>(constant)) {
      result.push_back(std::get<u32>(constant));
      result.push_back(0);
    }
    else if(std::holds_alternative<u64>(constant)) {
      result.push_back(std::get<u64>(constant) & 0xFFFFFFFF);
      result.push_back((std::get<u64>(constant) >> 32) & 0xFFFFFFFF);
    }

  return result;
}

Assembler::Label Assembler::create_label() {
  return Label{ current_label_count++ };
}

Assembler::Label Assembler::create_constant(const Constant& val) {
  auto new_label = create_label();
  constants[new_label.index] = val;
  return new_label;
}

void Assembler::push_label(Label label) {
  buffer.push_back(label);
}

FUNC_DEFS

}
}
}
'''

instruction_template_h = "  void FUNC_NAME(ARGS_LIST);"

instruction_template_cpp = """void Assembler::FUNC_NAME(ARGS_LIST) {
FUNC_BODY
}"""

def log(*args):
  if verbose:
    print(*args)

def generate_assembler_files(input_path: str, header_path: str, cpp_path: str):
  with open(input_path, 'r') as f:
    json_data = json.load(f)

  header_parts = []
  cpp_parts = []

  for category_data in json_data["instruction_categories"]:
    category = category_data.get("category", "Unknown Category")
    section = category_data.get("section", "Unknown Section")

    encoding_pattern = category_data.get("encoding")
    mappings = category_data.get("mappings", {})
    defaults = category_data.get("defaults", {})

    for instruction in category_data.get("instructions"):
      header_part, cpp_part = process_instruction(encoding_pattern, mappings, instruction, defaults)
      header_parts.append(header_part)
      cpp_parts.append(cpp_part)

  if header_path:
    header = header_file_template.replace('FUNC_LIST', '\n'.join(header_parts))
    print(f"Wrote Header file '{header_path}' with {len(header_parts)} functions")
    with open(header_path, "w") as f:
      f.write(header)

  if cpp_path:
    cpp = cpp_file_template.replace('FUNC_DEFS', '\n\n'.join(cpp_parts))
    print(f"Wrote CPP file '{header_path}' with {len(cpp_parts)} functions")
    with open(cpp_path, "w") as f:
      f.write(cpp)


def deduce_funcarg_from_name(argname: str) -> FunctionArgument:
  if argname[0] == 'W': return FunctionArgument(argname, ArgType.GPR32)
  if argname[0] == 'X': return FunctionArgument(argname, ArgType.GPR64)
  if argname[0] == 'S': return FunctionArgument(argname, ArgType.FP32)
  if argname[0] == 'D': return FunctionArgument(argname, ArgType.FP64)
  if argname[0] == 'Q': return FunctionArgument(argname, ArgType.FP128)

  if argname.startswith('imm'): return FunctionArgument(argname, ArgType.Immediate)
  if argname == 'shift': return FunctionArgument(argname, ArgType.ShiftMode)
  if argname == 'extend': return FunctionArgument(argname, ArgType.ExtensionMode)
  if argname == 'cond': return FunctionArgument(argname, ArgType.Condition)
  if argname == 'label': return FunctionArgument(argname, ArgType.Label)
  if argname == 'amount': return FunctionArgument(argname, ArgType.Immediate)

def get_function_params(asm, mappings) -> List[FunctionArgument]:
  args = re.findall("<[A-Za-z0-9_]+>", asm)
  log("Function Params:", args)
  return [deduce_funcarg_from_name(argname[1:-1]) for argname in args]

def generate_cpp_func_args(function_args):
  cpp_args = {}
  for func_arg in function_args:
    log(func_arg)
    if func_arg.type == ArgType.GPR32:
      cpp_args[func_arg.name] = f"const GPR<32> {func_arg.name}"
    elif func_arg.type == ArgType.GPR64:
      cpp_args[func_arg.name] = f"const GPR<64> {func_arg.name}"
    elif func_arg.type == ArgType.FP32:
      cpp_args[func_arg.name] = f"const FPR<32> {func_arg.name}"
    elif func_arg.type == ArgType.FP64:
      cpp_args[func_arg.name] = f"const FPR<64> {func_arg.name}"
    elif func_arg.type == ArgType.FP128:
      cpp_args[func_arg.name] = f"const FPR<128> {func_arg.name}"
    elif func_arg.type == ArgType.Immediate:
      cpp_args[func_arg.name] = f"const Immediate {func_arg.name}"
    elif func_arg.type == ArgType.Condition:
      cpp_args[func_arg.name] = f"const Condition::Code {func_arg.name}"
    elif func_arg.type == ArgType.Label:
      cpp_args[func_arg.name] = f"const Label {func_arg.name}"
    elif func_arg.type == ArgType.ShiftMode:
      cpp_args[func_arg.name] = f"const RegisterShift::Mode {func_arg.name}"
    elif func_arg.type == ArgType.ExtensionMode:
      cpp_args[func_arg.name] = f"const Extension::Mode {func_arg.name}"
    else:
      raise ''
  return cpp_args

def get_bits_size(pattern, index):
  size = 0
  while index < len(pattern) and pattern[index] in "0123456789":
    size = size * 10 + int(pattern[index])
    index += 1
  return size

class Placement:
  def __init__(self, symbol, lshift, nbits):
    self.symbol = symbol
    self.lshift = lshift
    self.nbits  = nbits

def generate_cpp_part(encoding_pattern, mnemonic, instruction, mappings, cpp_args, function_args):

  placements = {}
  bits = []
  index = 32

  # Lines composing the body of the function
  func_body = []

  # Add in any definitions from the mappings for this category
  for mapping_name, mapping_code in sorted(mappings.items()):
    func_body.append(mapping_code)

  # Add in any per-instruction mapping info
  for key, val in instruction.items():
    if key != 'asm' and type(val) == str:
      func_body.append(val)

  # Create a map of Rxyz -> [XWSDQ]xyz, and determine if any arguments are labels
  generic_to_specific_register_names = {}
  accepts_label = False

  for func_arg in function_args:
    if func_arg.type in (ArgType.GPR32, ArgType.GPR64, ArgType.FP32, ArgType.FP64, ArgType.FP128):
      log(f"Created reg {func_arg.name} -> {'R' + func_arg.name[1:]}")
      generic_to_specific_register_names['R' + func_arg.name[1:]] = func_arg.name

    elif func_arg.type == ArgType.Label:
      accepts_label = True


  log("")
  log(instruction["asm"])

  for component in encoding_pattern.split('|'):
    log(f" - Component: {component}")

    if component[0] in "01":
      bits.append(component)
      index -= len(component)
      log(f"  - interpreted as literal bits (length {len(component)}")

    elif component[0] == 'R':
      bits.append("00000")
      index -= 5
      placements[component] = Placement(generic_to_specific_register_names[component], index, 5)
      log(f"  - interpreted as register (length 5)")

    elif ':' in component:
      field, length = component.split(':')
      length = int(length)
      log(f"  - Field: '{field}', Length = {length}")

      # Interpolated from the instruction
      if field in instruction:
        index -= length
        if type(instruction[field]) == int:
          new_bits = format( int(instruction[field]), f'0{length}b')
          log(f"  - Interpolated {field} -> {new_bits}")
        else:
          new_bits = '0' * length
          # TODO: Handle case where field maps to a CPP string
          placements[field] = Placement(field, index, length)
        bits.append( new_bits )

      # Has a field separator, but not defined per-instruction. Should be an immediate.
      else:
        # ASSUMPTION: All branch instructions with a label have a single immediate in the encoding!
        index -= length
        placements[field] = Placement(field, index, length)
        bits.append( '0' * length )
        log(f" - Placement '{field}' @index={index} length={length}'")

    elif component == 'cond':
      bits.append("0000")
      length = 4
      index -= length
      placements[component] = Placement(component, index, length)

    else:
      print(f"!!!!!!! Unhandled component '{component}'", instruction)

    log(f" - Now at index={index}")

  for key, val in placements.items():
    log(f" - Placement {key} : {val.lshift} lsl, {val.nbits} bits")

  ###########################################

  final_bits = ''.join(bits)
  func_body.append(f"u32 bits = 0b{final_bits};")
  log(f" - Final Bits: {final_bits}")

  for placement_name, placement in placements.items():
    if placement_name.startswith('R'):
      func_body.append(f"bits |= ({placement.symbol}.value & {bin((1 << placement.nbits) - 1)}) << {placement.lshift};");
    elif placement_name in ['cond', 'shift', 'extend']:
      func_body.append(f"bits |= ({placement.symbol} & {bin((1 << placement.nbits) - 1)}) << {placement.lshift};");
    else:
      # Don't record a placement for labels. That logic is dealt with later during assembly.
      if not (accepts_label and placement.symbol == 'imm'):
        func_body.append(f"bits |= ({placement.symbol}.value & {bin((1 << placement.nbits) - 1)}) << {placement.lshift};");

  func_body.append("Intermediate intermediate(bits, buffer.size());")

  # If this instruction accepts a label, assume that the 'imm' field is the place to encode it
  if accepts_label:
    log("Instruction accepts a label, going to setup 'imm' encoding field for passed in label")

    placement = placements["imm"]
    func_body.append("intermediate.label_assignment = label.index;")
    func_body.append(f"intermediate.label_lshift = {placement.lshift};")
    func_body.append(f"intermediate.label_nbits = {placement.nbits};")

  func_body.append("emit(intermediate);")

  func_name = mnemonic
  args_list = ', '.join(cpp_args)

  func_body = ["  " + line for line in func_body]
  func_body = '\n'.join(func_body)

  return instruction_template_cpp.replace("FUNC_NAME", func_name) \
                                 .replace("ARGS_LIST", args_list) \
                                 .replace("FUNC_BODY", func_body)

def process_instruction(encoding_pattern, mappings, instruction, default_values) -> Tuple[str, str]:
  # Build the encoded form and process placeholders
  function_args = get_function_params(instruction["asm"], mappings)
  cpp_args = generate_cpp_func_args(function_args)
  mnemonic = re.findall(r"^[A-Za-z0-9_]+", instruction["asm"])[0]

  # Construct "type name = default, type ..."
  cpp_args_with_defaults = []
  for key, val in cpp_args.items():
    if key in default_values:
      cpp_args_with_defaults.append(f"{val} = {default_values[key]}")
    else:
      cpp_args_with_defaults.append(f"{val}")

  header_declaration = instruction_template_h.replace('FUNC_NAME', mnemonic).replace('ARGS_LIST', ', '.join(cpp_args_with_defaults))
  cpp_part = generate_cpp_part(encoding_pattern, mnemonic, instruction, mappings, cpp_args.values(), function_args)

  return (header_declaration, cpp_part)

def main():
  json_path = sys.argv[1]
  header_path = sys.argv[2] if sys.argv[2].endswith('.h') else None
  cpp_path = sys.argv[2] if sys.argv[2].endswith('.cpp') else None

  generate_assembler_files(json_path, header_path=header_path, cpp_path=cpp_path)

if __name__ == "__main__":
  main()
